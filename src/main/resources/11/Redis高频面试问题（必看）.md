# Redis高级

**课程高频面试问题整理：**

## 1、Redis常用数据类型有哪些？

支持五种数据类型：String（字符串），Hash（哈希），List（列表），Set（集合）及Zset(sorted set：有序集合)。

## 2、你们项目中运用场景都有哪些啊？

**计数器**：对 string 进行自增自减运算，从而实现计数器功能。redis 内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。比如每日登录次数计数，每月免费提现次数等待。

**热点数据缓存**：将热点数据放到内存中。如首页排行榜数据，具有很大访问频次，使用zset可以实现基于score分数排序；。

**会话缓存**：用redis统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。

**临时数据存储**：比如验证码等等

**取数据交集、并集**：基于redis  set 的特性可以对共同好友进行很方便的查询。

**分布式事务锁的使用**：基于set lock requestId nx ex time 模式可以很方便编写分布式事务锁

## 3、Redis 键过期删除如何实现的？

Redis中可以设置键的过期时间，到期后自动进行删除，那么redis中是怎么实现过期删除的？

**定时过期**：每个设置过期时间的key都需要**创建一个定时器**，到过期时间就会**立即清除**。该策略可以**立即清除过期的数**据，**对内存很友好**；但是会**占用大量的CPU资源**去处理过期的数据，从而**影响缓存的响应时间和吞吐量**。

**惰性过期**：只有当**访问一个key时**，**才会判断该key是否已过期**，过期则清除。该策略可以**最大化地节省CPU资源**，却**对内存非常不友好**。**极端情况**可能出现**大量的过期ke**没有再次被访问**，从而不会被清除，**占用大量内存。

**定期过期**：每隔一定的时间，会扫描**一定数量**的**数据库的expires字典**中**一定数量的key**，并清除其中已过期的key。该策略是前两者的一个**折中方案**。通过调整**定时扫描的时间间隔**和**每次扫描的限定耗时**，可以在不同情况下使得CPU和内存资源达到**最优的平衡效果**。

说明：图中知识点理解即可：

![image-20210519212014236](.\assets\image-20210519212014236.png)

![image-20210519205101890](.\assets\image-20210519205101890.png)



## 4、Reids数据淘汰策略

当新数据进入redis时，如果内存不足，是下面这样一个流程：

1、首先执行存储命令前会调用**freeMemoryIfNeeded()**检测内存是否充足。

2、如果内存不满足新 加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为逐出算法。

3、逐出算法（maxmemory-policy）分为下面八种，其中lru是使用时间最短，离当前时间最久，lfu是使用的次数最少。

![image-20210519222329532](.\assets\image-20210519222329532.png)

其次redis还可通过maxmemory来调大内存，以满足存储空间，还可通过mxdmemory-samples参数指定但内存不够时删除多少数据。

最后如果对当对所有数据尝试完毕，  仍不能达到内存清理的要求，将会报错：

```shell
(error) OOM command not allowed when used memory >'maxmemory'
```

## 5、主从复制流程

三个阶段：

1、建立连接：slave连接master；

![image-20210520013340093](.\assets\image-20210520012005617.png)

2、数据同步：master数据同步到slave（RDB+AOF）

![image-20210521190549096](.\assets\image-20210521190549096.png)

3、命令传播：将增量命令传播到slave（命令传播）（类似AOF）

![image-20210520020725279](.\assets\image-20210520020725279.png)



主从节点在数据同步阶段，主节点会根据当前状态的不同执行不同复制操作，包括：全量复制 和 部分复制，这

- **全量复制**：用于首次复制或者其他不能进行部分复制的情况。全量复制是一个非常重的操作，一般我们都要规避它
- **部分复制**：用于从节点短暂中断的情况（网络中断、短暂的服务宕机）。部分复制是一个非常轻量级的操作，因为它只需要将中断期间的命令同步给从节点即可，相比于全量复制，它显得更加高效。

从上面过程我们就可以看出，全量复制是一个非常重的操作过程，它的开销主要有：

1. 主节点执行 bgsave 过程，在持久化那篇博客中我们知道该过程是非常消耗 CPU、内存(页表复制)、硬盘 IO 的
2. 主节点发送 RDB 给从节点的网络开销
3. 从节点清空 RBD 文件（如果有）和加载 RDB 文件，同时该过程是阻塞的，无法响应客户端命令
4. 如果从节点开启了 AOF，则还有 bgrewriteaof 的开销

所以，我们需要尽可能避免全量复制，当然第一次建立连接数据同步是必不可免的，但是其他的情况我们是可以避免的。

第一次建立连接进行数据同步是全量复制，还有以下几种情况也是全量复制：

1. 从节点发送 psync {runid} {offset} 时，runid 与当前主节点的 runid 不匹配则进行全量复制
2. 从节点所需要同步数据的偏移量 offset 不在**复制积压缓冲区**中，也会进行全量复制，关于复制积压缓冲区。

## 6、缓存穿透？缓存击穿？缓存雪崩？

**缓存穿透：**是指**缓存和数据库中都没有的数据**，而用户**不断发起请求**，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，**攻击会导致数据库压力过大**。

​				![image-20210424170256288](.\assets\image-20210424170256288.png)

​			     **解决方案：**

​						1）、接口层增加校验，如用户鉴权或者白名单校验，id做基础校验，id<=0的直接拦截；

​						2）、从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击；

​						3）、引入布隆过滤器，过滤一些异常的请求。



**缓存击穿：**是指**缓存中没有但数据库中有的数据**（一般是缓存时间到期），这时由于**并发用户特别多**，同时**读缓存没读到的某一个数据**，又同时**去数据库去取数据**，引起**数据库压力瞬间增大**，造成过大压力。

![image-20210424170459312](.\assets\image-20210424170459312.png)

​				**解决方案：**

​							1）、设置热点数据不过期；

​							2）、分布式锁，第一时间去数据库获取数据填充到redis中，但是这个过程需要加分布式锁，防止所有线										程都去读取数据库，一旦有一个线程去数据库获取数据了，其他线程取锁失败后可设置一个合理睡										眠时间之后再去尝试去redis中获取数据；

**缓存雪崩**：缓存雪崩是指**缓存中数据大批量到过期时间**，而**查询数据量巨大**，引起**数据库压力过大甚至down机**。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是大批量数据都过期了，大量数据都从redis中查不到，从而查数据库。

​				![image-20210424120743820](.\assets\image-20210424120743820.png)

​			   **解决方案**：

​							1）、缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。

​							2）、如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。

​							3）、允许的话，设置热点数据永远不过期。	

​							4）、要保证redis的高可用，可以使用主从+哨兵或redis cluster，避免服务器不可用；

​							5）、使用redis的持久化RDB+AOF组合策略，防止缓存丢失并且可以快速恢复数据；

## 7、Redis是单线程的，redis为何设置为单线程呢？单线程还那么快，为什么？

概括就是：

- ​						redis完全基于内存
- ​						数据结构简单
- ​						采用单线程，避免了加锁、释放锁、死锁、线程间切换等消耗
- ​						使用多路I/O复用模型，非阻塞IO

详细说的话：

**Redis 的线程模型**：基于非阻塞的IO多路复用机制的线程模型，**单线程**

Redis 是基于 **reactor** 模式开发了**网络事件处理器**，这个处理器叫做**文件事件处理器**（file event handler）。由于这个文件事件处理器是**单线程的**，所以 Redis 才叫做

​	**单线程的模型**。采用 **IO 多路复用机制同时监听多个 Socket**，根据 **socket 上的事件**来选择对应的**事件处理器**来**处理这个事件**。模型如下图：

![image-20210622191653269](.\assets\image-20210622191653269.png)

上图得知，文件事件处理器的结构包含了四个部分：

- **多个 Socket**：客户单发起多个 socket，每个socket 会产生不同的事件，不同的事件对应着不同的操作
- **IO 多路复用程序**：IO 多路复用程序监听着这些 Socket，当这些 Socket 产生了事件，IO 多路复用程序会将这些事件放到一个队列中。
- **文件事件分派器**：通过队列，将事件以有序、同步、每次一个事件的方式向文件时间分派器中传送，文件事件分派器将事件按类型分派给不同的事件处理器进行处理。
- **事件处理器**：分为连接应答处理器、命令请求处理器、命令回复处理器，每个处理器对应不同的 socket 事件。



![image-20210622192220695](.\assets\image-20210622192220695.png)

## 8、分布式事务锁怎么实现的？会有什么问题？

 通过setnx上锁方式实现，但是不注意写法很可能会出现很多问题；

​		**错误用法**：先通过setnx上锁，再通过expire设置过期时间，最后执行完任务后手动del释放锁；

​		**场景一问题**（**死锁**）：通过setnx上锁后**出现异常**，导致**无法**去expire**设置锁的过期时间**，更**无法**最后去**手动释放锁**，造成**死锁**！

​		解决：使用上锁最新写法，**保证上锁、设置过期时间**一步完成的**原子性**：**set(lockKey,value,nx,ex,exporeTime);**

​		**场景二问题**（**误删锁**）：**A机器**中**上锁并设置过期时间**完成以后后，系统出现了**阻塞**，导致**锁到了过期时间并自动删除**了，这时**还没有**执行**手动释放锁**的操作，这个时候**B机器上锁成功**，并去执行任务，**任务还未执行完**，**A机器**反应过来了，继续**执行了手动释放锁**的操作，**把B机器**上的**锁给误删了**。

​		解决：上锁同时**加上一个锁id**，如当前线程ID，将**锁id**存入**value**值并记录在变量中，**手动释放锁**的时候比较一下value中的锁id跟变量中id是否一致，也就是**判断一 下是否自己还在持有锁**，如果不是，就不执行删除操作了。

​		**场景三问题**（**误删锁**）：这种误删锁是基于场景2**判断锁id**和**释放锁操作**这两步没有保证原子性所导致的。

 具体为：A机器**带锁id方式取锁、设置过期时间并执行完任务后**，希望通过判断比较锁id之后去释放锁，**判断通过后系统出现阻塞**，阻塞到锁也到了过期时间自动释放了锁，这时还未进行手动释放锁操作，这个时候B机器上锁成功，并去执行任务，**任务还未执行完**，**A机器**反应过来了，继续**执行了手动释放锁**的操作，**把B机器**上的**锁给误删了**。

​		解决：保证**判断锁和释放锁的原子性**：使用redis执行**LUA脚本**，保证**一步执行判断锁和释放锁**。

		String luaScript = 'if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end';

​		redisClient.eval(luaScript , Collections.singletonList(key), Collections.singletonList(threadId));

​		**场景四问题（锁续命）**：这种场景是指线程中任务还没执行完，锁就已经到过期时间，这种情况可以给任务执行线程添加守护线程，守护线程负责对锁的expire时间进行监控，每当到过期前一秒就对过期进行判断，如果任务还在进行且锁马上过期，则对过期时间重新进行设置。

​		**综上**：正确使用redis分布式事务锁需要保证两个原子性：

​						1、上锁和设置过期时间需要保证原子性；

​						2、 判断锁ID是否为自己所有和解锁需要保证原子性；

   	**补充**：其实关于上述四个场景的问题，使用redis客户端**Redisson**都能够得到很好的解决，redisson**内部已经实现了上述几点问题的解决机制**，原理同上。	

## 8、redis如何保证高可用？master挂了怎么办？

Redis 主从部署时，可以启动 哨兵模式、（拥有监控及选择的功能）；

redis-cluster 分布式集群；

## 9、你们公司redis采用的哪种方式部署的？有几个节点？

集群模式 3主3从，槽的概念





