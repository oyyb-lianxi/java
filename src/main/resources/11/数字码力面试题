1、线上频繁full gc怎么快速定位问题，如何通过jvm参数优化G1垃圾回收器
2、metaSpace内存泄漏的场景有哪些？如何通过工具分析泄漏根源？

3、ThreadLocal的内存泄漏问题如何避免？spring框架中哪些场景会用到ThreadLocal？
ThreadLocal内存泄漏的原因是因为ThreadLocalMap的key是弱引用，值是强引用，当key被回收后，值没有被及时清理，特别是如果在线程池中使用，久而久之会导致这一大块内存不会被回收。
。所以我们在使用ThreadLocal的时候要严格遵守try-finally+remove()来清理。但是我们在工作中一般都是使用static final修饰的，这样它的key就不再是弱引用，它的生命周期跟容器保持一致。并且不会被频繁创建threadLocal实例。
spring框架中：请求上下文管理RequestContextHolder，事务管理TransactionSynchronizationManager。安全上下文SecurityContextHolder。本地化上下文LocaleContextHolder
强软弱虚：
强：只要引用关系存在，对象就不会被回收。
软：在内存溢出之前回收。
弱：下一次GC就会回收。
虚: 适用于需要在对象被垃圾回收时得到通知的场景

4、对比reentrantLock和synchronized的底层实现
synchronized是关键字，reentrantLock是lock的实现类。sync的底层是使用对象的内置锁（或者监视锁），它是基于monitor实现的，每个java的对象头中都包含一个锁记录，记录中包含了锁的状态信息。支持锁升级。执行完毕自动释放。
reentrantLock底层是基于AQS实现的，使用一个int类型的state变量表示锁的状态，记录锁的重入次数。0是无锁，每次+1。支持超时，支持中断，需要手动是释放。AQS 使用一个 FIFO 队列来管理等待获取锁的线程

5、AQS如何管理线程阻塞队列的？
一个是使用int类型的state表示状态。依赖于先进先出（FIFO）等待队列的阻塞锁和相关同步器。
通过队列中节点的添加，移除，唤醒来管理队列的阻塞和唤醒。先尝试获取锁，失败则加入队列并且阻塞。释放锁后则唤醒后续节点。
同步对列的结构包括了：节点（同步队列中每个节点表示一个等待的线程，每个节点包含了一个thread对象和一些状态信息）。头节点（表示当前持有锁或者即将获取锁的线程）。尾节点（表示最后一个加入队列的线程）。

6、如何设计一个高性能的本地缓存
基于hashMap

7、spring中使用了哪些设计模式？
单例，工厂（只有一个工厂接口或者类适用于单一对象场景）。抽象工厂（有多个工厂接口使用系列场景）、策略、模板方法。适配器、包装器。
8、如何使用策略模式优化复杂的支付流程（如：微信支付，支付宝支付，银行卡支付）

9、dubbo原理,springCloud原理。

10、查询每门科目分数大于80学生
11、翻转字符串
====================
1、hashMap为啥不安全？怎么解决。
hashMap不安全是因为在高并发场景下，可能存在a读取值，b同时put同一个key导致线程读取到数据不一致的问题。还有多级嵌套的hashMap可能会造成死锁。多个线程对hashMap进行插入操作可能会导致hashMap内部链表形成环。
解决：使用concurrentHashMap。它是通过分段锁来实现。后面又拆分成了一个值一个锁。锁的粒度更细了。或者使用collection.synchronizedMap。可以将hashMap包装成安全的版本。或者自己手动枷锁。

2、kafka跟rebbitMq怎么保证消息不重复消费？唯一id怎么来的？雪花算法怎么解决时钟回拨问题

时钟回拨问题：当系统时间被向后调整，在分布式系统中各个节点的时间存在偏差会导致生成的id变小。从而引发重复id问题。
使用重试机制，知道系统时间恢复正常。使用网络时间协议同步时间确保各个节点时间一致。使用时间戳缓存记录上一次生成id的时间，在发生回拨的情况下使用缓存的时间戳来生成id
3、你们项目中mq主要作用是什么？ribbitmq怎么刷盘？
4、spring怎么解决循环依赖？
5、事务的特性。spring事务的传播方式。事务什么时候会失效？为什么失效
事务方法中抛出了违背捕获的异常，或者捕获了异常没有正确处理。
事务方法被多次调用导致事务嵌套。
事务执行时间超过了配置的超时时间。
多线程环境下也会失效
事务没有被public方法修饰：spring事务管理器是通过代理管理事务的，spring使用的是jdk动态管理（要求被代理的方法必须是public）和cglb代理（可以代理非public方法）。spring默认使用jdk
6、你工作中用的哪种分布式事务？什么模式？有什么好处？
7、mybatis的底层实现、#{}和${}的区别
8、springBoot的自动装配怎么实现,springBootAppliaction中有哪些注解。
9、自己实现一个starter
一个starter一般包含：自动配置类，配置属性类，核心功能类。
首先创建一个maven工程，添加springboot-starter和autoconfig等相关依赖自定义我的starter依赖
创建一个配置属性类@configurationProperties用于读取配置文件中的属性；
创建自动配置类@configuartion @enableConfigurationProrerties（MystarterProperties.class） @ConditionalOnClass(MyService.class)指定myservice类
创建services提供具体功能 
最后在meta-inf中的spring.factorices中注册自动配置类
10、jdk动态代理怎么实现的
11、怎么排查服务器卡顿
12、mysql索引，正序索引跟倒排索引的区别
mysql索引结构是基于B+树是一种多路平衡查找树，由叶子节点与非叶子节点组成，非叶子节点储存的是索引值和指向子节点的指针，不存储实际数据，叶子节点存储的完整的数据行并通过双向链表连接。
通常主键就是聚簇索引。如果没有主键，InnoDB会选择第一个非空的唯一索引作为聚簇索引，如果都没有，则会隐式创建一个自增的聚簇索引。
在ES中索引结构主要基于倒排索引，倒排索引以关键词为中心，每一个关键词对应一个文档id列表。对于给定的关键词可以快速找到包含该关键词的所有文档id。通常是以关键词为键，文档id列表为值储存。
正序索引是以文档为中心，每个文档id对应一个文档内容。对于给定的文档id可以快速找到对应的文档内容。以文档id为键，文档内容为值存储。
13、线程的创建方式。线程池的核心参数。你们公司是怎么配置的。为什么这么配置，你们用的哪种拒绝策略。
继承thread类重新run方法
实现runnable接口重新run方法
实现collable接口重新call方法
线程池：核心，队列，最大，工厂，拒绝策略，空闲线程的存活时间，时间单位； 核心线程参数配置：cpu*cpu利用率*任务耗时； 队列参数：根据内存做压测。
拒绝策略：直接抛异常，丢弃当前任务，丢弃工作队列中最老的任务接纳被拒绝的任务，调用线程自己执行



