1、线上频繁full gc怎么快速定位问题，如何通过jvm参数优化G1垃圾回收器
2、metaSpace内存泄漏的场景有哪些？如何通过工具分析泄漏根源？

3、ThreadLocal的内存泄漏问题如何避免？spring框架中哪些场景会用到ThreadLocal？
ThreadLocal内存泄漏的原因是因为ThreadLocalMap的key是弱引用，值是强引用，当key被回收后，值没有被及时清理，特别是如果在线程池中使用，久而久之会导致这一大块内存不会被回收。
。所以我们在使用ThreadLocal的时候要严格遵守try-finally+remove()来清理。但是我们在工作中一般都是使用static final修饰的，这样它的key就不再是弱引用，它的生命周期跟容器保持一致。并且不会被频繁创建threadLocal实例。
spring框架中：请求上下文管理RequestContextHolder，事务管理TransactionSynchronizationManager。安全上下文SecurityContextHolder。本地化上下文LocaleContextHolder
强软弱虚：
强：只要引用关系存在，就算造成oom也不会对该对象进行回收。
软：在内存溢出之前回收。
弱：不管当前内存是否足够，下一次GC就会回收。
虚: 就跟没有任何引用一样，并不会决定对象的生命周期，适用于需要在对象被垃圾回收时得到通知的场景

4、对比reentrantLock和synchronized的底层实现
synchronized是关键字，reentrantLock是lock的实现类。sync的底层是使用对象的内置锁（或者监视锁），它是基于monitor实现的，每个java的对象头中都包含一个锁记录，记录中包含了锁的状态信息。支持锁升级。执行完毕自动释放。
reentrantLock底层是基于AQS实现的，使用一个int类型的state变量表示锁的状态，记录锁的重入次数。0是无锁，每次+1。支持超时，支持中断，需要手动是释放。AQS 使用一个 FIFO 队列来管理等待获取锁的线程

5、AQS如何管理线程阻塞队列的？
一个是使用int类型的state表示状态。依赖于先进先出（FIFO）等待队列的阻塞锁和相关同步器。
通过队列中节点的添加，移除，唤醒来管理队列的阻塞和唤醒。先尝试获取锁，失败则加入队列并且阻塞。释放锁后则唤醒后续节点。
同步对列的结构包括了：节点（同步队列中每个节点表示一个等待的线程，每个节点包含了一个thread对象和一些状态信息）。头节点（表示当前持有锁或者即将获取锁的线程）。尾节点（表示最后一个加入队列的线程）。

6、如何设计一个高性能的本地缓存
基于hashMap

7、spring中使用了哪些设计模式？
单例，工厂（只有一个工厂接口或者类适用于单一对象场景）。抽象工厂（有多个工厂接口使用系列场景）、策略、模板方法。适配器、包装器。
8、如何使用策略模式优化复杂的支付流程（如：微信支付，支付宝支付，银行卡支付）

9、dubbo原理,springCloud原理。

10、查询每门科目分数大于80学生
SELECT s.id, s.name
FROM students s
JOIN scores sc ON s.id = sc.student_id
GROUP BY s.id, s.name
HAVING MIN(sc.score) > 80;

11、翻转字符串
1.
    public static String reverseString(String s) {
        return new StringBuffer(s).reverse().toString();
    }
2.
    public static String reverseStringManually(String s) {
        char[] charArray = s.toCharArray();
        int n = charArray.length;
        for (int i = 0; i < n / 2; i++) {
            char temp = charArray[i];
            charArray[i] = charArray[n - 1 - i];
            charArray[n - 1 - i] = temp;
        }
        return new String(charArray);
    }

====================
1、hashMap为啥不安全？怎么解决。
hashMap不安全是因为在高并发场景下，可能存在a读取值，b同时put同一个key导致线程读取到数据不一致的问题。还有多级嵌套的hashMap可能会造成死锁。多个线程对hashMap进行插入操作可能会导致hashMap内部链表形成环。
解决：使用concurrentHashMap。它是通过分段锁来实现。后面又拆分成了一个值一个锁。锁的粒度更细了。或者使用collection.synchronizedMap。可以将hashMap包装成安全的版本。或者自己手动枷锁。

2、kafka跟rebbitMq怎么保证消息不重复消费？唯一id怎么来的？雪花算法怎么解决时钟回拨问题
kafka使用消费者组来保证消息的消费，每个消费者组内的消费者会共享消息，确保每条消息只被组内的一个消费者消费。
kafka使用偏移量类记录消费者消费到的消息位置，消费者可以手动或者自动提交偏移量来确保消息不被重复消费。
kafka2.0引入了幂等性，通过设置enable.idempotence=true 生产者确保消息在生产者和kafka直接的传输过程中不会重复。
kafka支持事务性消息，确保消息的生产，消费和提交是一个原子操作。

ribbit使用消息确认机制来确保消息不被重复消费。消费者处理完消息后可以手动确认消息。应用层幂等性。

时钟回拨问题：当系统时间被向后调整，在分布式系统中各个节点的时间存在偏差会导致生成的id变小。从而引发重复id问题。
使用重试机制，知道系统时间恢复正常。使用网络时间协议同步时间确保各个节点时间一致。使用时间戳缓存记录上一次生成id的时间，在发生回拨的情况下使用缓存的时间戳来生成id

3、你们项目中mq主要作用是什么？ribbitmq怎么刷盘？
削峰填谷，异步通知。
1.声明持久化队列（使用 queueDeclare 方法将队列设置为持久化） 2.发布持久化消息（在发布消息时，将消息的 delivery_mode 设置为 2） 3.配置刷盘策略 4.消息确认机制（确保在确认之前已经被持久化）
同步刷盘：确保每条消息在被确认之前都被写入磁盘。提供最高的可靠性但是会显著降低性能
异步刷盘：允许消息在内存中累积一段时间之后再批量写入磁盘，可以提高性能但是可能会导致在系统崩溃的时候丢失掉部分信息。

4、spring怎么解决循环依赖？
spring通过三级缓存解决循环依赖。一级缓存用于缓存已经完全初始化完成的实例。二级缓存用于缓存早期暴露的实例，这些实例没有完全加载完成，但是已经能够被使用。三级缓存用户创建早期暴露的实例。

5、事务的特性。spring事务的传播方式。事务什么时候会失效？为什么失效
事务方法中抛出了违背捕获的异常，或者捕获了异常没有正确处理。
事务方法被多次调用导致事务嵌套。
事务执行时间超过了配置的超时时间。
多线程环境下也会失效
事务没有被public方法修饰：spring事务管理器是通过代理管理事务的，spring使用的是jdk动态管理（要求被代理的方法必须是public）和cglb代理（可以代理非public方法）。spring默认使用jdk

6、你工作中用的哪种分布式事务？什么模式？有什么好处？
seata。有三个角色：TC事务协调者 协调事务提交和回滚；TM事务管理器开始事务 提交 回滚；RM字段管理器 与TM交谈分支事务的注册和报告。
支持四种模式XA（强一致性）,TCC（分阶段，最终一致性，有业务入侵，需要人为编写try，confirm，cancel接口）,AT（基于undolog日志回滚，写操作时候会生成前置 后置镜像。分阶段，最终一致性，无业务入侵，不需要手动回滚事务，可能存在脏读问题，默认读未提交）,SAGA（长事务模式）四种模式 我们使用了AT模式。

7、mybatis的底层实现、#{}和${}的区别
MyBatis的底层实现涉及多个核心组件和机制，包括配置解析、SQL 解析、动态 SQL、缓存、事务管理等
创建 SqlSessionFactory：通过 SqlSessionFactoryBuilder 创建 SqlSessionFactory。
创建 SqlSession：通过 SqlSessionFactory 创建 SqlSession。
获取 Mapper 接口：通过 SqlSession 获取 Mapper 接口的代理对象。
通过sqlSource解析sql，通过handler处理执行结果。
执行 SQL 语句：通过 Mapper 接口的方法执行 SQL 语句。
处理结果：处理查询结果，返回给调用者。
关闭资源：关闭 SqlSession 和 SqlSessionFactory。

#{}是占位符，适用于插入参数值的场景，如 WHERE 子句中的条件值，${}是字符串拼接，适用于需要动态生成表名、列名等 SQL 语句的场景。会有sql注入的风险。工作中遇到过 限制输入。

8、springBoot的自动装配怎么实现,springBootAppliaction中有哪些注解。
定义配置类：创建一个配置类，使用 @Configuration 注解标记，并包含 @Bean 方法。
添加条件注解：在配置类上添加条件注解，根据特定条件决定是否应用配置。
注册配置类：在 META-INF/spring.factories 文件中注册配置类。
启用自动装配：在主类上使用 @SpringBootApplication 注解启用自动装配。
@EnableAutoConfiguration  @ComponentScan  @Configuration  @Service  @Controller  @Autowired @Value
9、自己实现一个starter
一个starter一般包含：自动配置类，配置属性类，核心功能类。
首先创建一个maven工程，添加springboot-starter和autoconfig等相关依赖自定义我的starter依赖
创建一个配置属性类@configurationProperties用于读取配置文件中的属性；
创建自动配置类@configuartion @enableConfigurationProrerties（MystarterProperties.class） @ConditionalOnClass(MyService.class)指定myservice类
创建services提供具体功能 
最后在meta-inf中的spring.factorices中注册自动配置类

10、jdk动态代理怎么实现的
JDK 动态代理通过 Proxy 类和 InvocationHandler 接口在运行时创建代理对象，可以在不修改目标对象代码的情况下，为对象添加额外的功能。
定义接口：定义目标对象和代理对象需要实现的接口。
实现接口：实现目标对象。
创建 InvocationHandler：实现 InvocationHandler 接口，定义处理方法调用的逻辑。
创建代理对象：使用 Proxy.newProxyInstance 方法创建代理对象。
通过代理对象调用方法：通过代理对象调用方法，实际调用的是 InvocationHandler 中的 invoke 方法。

11、怎么排查服务器卡顿

12、mysql索引，正序索引跟倒排索引的区别
mysql索引结构是基于B+树是一种多路平衡查找树，由叶子节点与非叶子节点组成，非叶子节点储存的是索引值和指向子节点的指针，不存储实际数据，叶子节点存储的完整的数据行并通过双向链表连接。
通常主键就是聚簇索引。如果没有主键，InnoDB会选择第一个非空的唯一索引作为聚簇索引，如果都没有，则会隐式创建一个自增的聚簇索引。
在ES中索引结构主要基于倒排索引，倒排索引以关键词为中心，每一个关键词对应一个文档id列表。对于给定的关键词可以快速找到包含该关键词的所有文档id。通常是以关键词为键，文档id列表为值储存。
正序索引是以文档为中心，每个文档id对应一个文档内容。对于给定的文档id可以快速找到对应的文档内容。以文档id为键，文档内容为值存储。

13、线程的创建方式。线程池的核心参数。你们公司是怎么配置的。为什么这么配置，你们用的哪种拒绝策略。
继承thread类重新run方法
实现runnable接口重新run方法
实现collable接口重新call方法
线程池：核心，队列，最大，工厂，拒绝策略，空闲线程的存活时间，时间单位； 核心线程参数配置：cpu*cpu利用率*任务耗时（根据io密集型区分cpu+1或者cpu*2）； 队列参数：根据内存做压测。
拒绝策略：直接抛异常，丢弃当前任务，丢弃工作队列中最老的任务接纳被拒绝的任务，调用线程自己执行

14、git相关操作。

15布隆过滤器：解决缓存穿透问题，判断ip是否访问过网站。底层是位数组，1代表存在0代表不存在。可以判断数据一定不存在，但是可能误判不存在的数据为存在。
执行bf.add()时候会有三个不同的hash算法计算出三个位置。只有三个位置全部都是1，才判断该数据存在。
误判如何解决：并发不高就让它去数据库查一次，没啥影响。并发非常大的话，在设计的时候需要优化过滤器参数增加为数组大小，或者采用多级过滤。另外需要增加兜底方案。
误判了就走兜底设置的默认值加默认过期时间，如果布隆过滤器误判了就走数据库查询，如果数据库不存在则缓存空值并且设置过期时间。
布隆过滤器快满了怎么办？布隆过滤器如何删除元素。
根据特征将元素分散到多个小布隆过滤器。使用计数布隆过滤器定期扫描删除计数器值低的项。增加一个独立的删除标记集合兼容传统布隆过滤器

